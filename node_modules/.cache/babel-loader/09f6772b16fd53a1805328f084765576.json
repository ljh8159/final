{"ast":null,"code":"import { applyProjectionDefaults } from './util.js';\n\n// Helper function to process units and to_meter\nfunction processUnit(unit) {\n  let result = {\n    units: null,\n    to_meter: undefined\n  };\n  if (typeof unit === 'string') {\n    result.units = unit.toLowerCase();\n    if (result.units === 'metre') {\n      result.units = 'meter'; // Normalize 'metre' to 'meter'\n    }\n    if (result.units === 'meter') {\n      result.to_meter = 1; // Only set to_meter if units are 'meter'\n    }\n  } else if (unit && unit.name) {\n    result.units = unit.name.toLowerCase();\n    if (result.units === 'metre') {\n      result.units = 'meter'; // Normalize 'metre' to 'meter'\n    }\n    result.to_meter = unit.conversion_factor;\n  }\n  return result;\n}\nfunction toValue(valueOrObject) {\n  if (typeof valueOrObject === 'object') {\n    return valueOrObject.value * valueOrObject.unit.conversion_factor;\n  }\n  return valueOrObject;\n}\nfunction calculateEllipsoid(value, result) {\n  if (value.ellipsoid.radius) {\n    result.a = value.ellipsoid.radius;\n    result.rf = 0;\n  } else {\n    result.a = toValue(value.ellipsoid.semi_major_axis);\n    if (value.ellipsoid.inverse_flattening !== undefined) {\n      result.rf = value.ellipsoid.inverse_flattening;\n    } else if (value.ellipsoid.semi_major_axis !== undefined && value.ellipsoid.semi_minor_axis !== undefined) {\n      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));\n    }\n  }\n}\nexport function transformPROJJSON(projjson, result = {}) {\n  if (!projjson || typeof projjson !== 'object') {\n    return projjson; // Return primitive values as-is\n  }\n  if (projjson.type === 'BoundCRS') {\n    transformPROJJSON(projjson.source_crs, result);\n    if (projjson.transformation) {\n      if (projjson.transformation.method && projjson.transformation.method.name === 'NTv2') {\n        // Set nadgrids to the filename from the parameterfile\n        result.nadgrids = projjson.transformation.parameters[0].value;\n      } else {\n        // Populate datum_params if no parameterfile is found\n        result.datum_params = projjson.transformation.parameters.map(param => param.value);\n      }\n    }\n    return result; // Return early for BoundCRS\n  }\n\n  // Handle specific keys in PROJJSON\n  Object.keys(projjson).forEach(key => {\n    const value = projjson[key];\n    if (value === null) {\n      return;\n    }\n    switch (key) {\n      case 'name':\n        if (result.srsCode) {\n          break;\n        }\n        result.name = value;\n        result.srsCode = value; // Map `name` to `srsCode`\n        break;\n      case 'type':\n        if (value === 'GeographicCRS') {\n          result.projName = 'longlat';\n        } else if (value === 'ProjectedCRS' && projjson.conversion && projjson.conversion.method) {\n          result.projName = projjson.conversion.method.name; // Retain original capitalization\n        }\n        break;\n      case 'datum':\n      case 'datum_ensemble':\n        // Handle both datum and ensemble\n        if (value.ellipsoid) {\n          // Extract ellipsoid properties\n          result.ellps = value.ellipsoid.name;\n          calculateEllipsoid(value, result);\n        }\n        if (value.prime_meridian) {\n          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180; // Convert to radians\n        }\n        break;\n      case 'ellipsoid':\n        result.ellps = value.name;\n        calculateEllipsoid(value, result);\n        break;\n      case 'prime_meridian':\n        result.long0 = (value.longitude || 0) * Math.PI / 180; // Convert to radians\n        break;\n      case 'coordinate_system':\n        if (value.axis) {\n          result.axis = value.axis.map(axis => {\n            const direction = axis.direction;\n            if (direction === 'east') return 'e';\n            if (direction === 'north') return 'n';\n            if (direction === 'west') return 'w';\n            if (direction === 'south') return 's';\n            throw new Error(`Unknown axis direction: ${direction}`);\n          }).join('') + 'u'; // Combine into a single string (e.g., \"enu\")\n\n          if (value.unit) {\n            const {\n              units,\n              to_meter\n            } = processUnit(value.unit);\n            result.units = units;\n            result.to_meter = to_meter;\n          } else if (value.axis[0] && value.axis[0].unit) {\n            const {\n              units,\n              to_meter\n            } = processUnit(value.axis[0].unit);\n            result.units = units;\n            result.to_meter = to_meter;\n          }\n        }\n        break;\n      case 'id':\n        if (value.authority && value.code) {\n          result.title = value.authority + ':' + value.code;\n        }\n        break;\n      case 'conversion':\n        if (value.method && value.method.name) {\n          result.projName = value.method.name; // Retain original capitalization\n        }\n        if (value.parameters) {\n          value.parameters.forEach(param => {\n            const paramName = param.name.toLowerCase().replace(/\\s+/g, '_');\n            const paramValue = param.value;\n            if (param.unit && param.unit.conversion_factor) {\n              result[paramName] = paramValue * param.unit.conversion_factor; // Convert to radians or meters\n            } else if (param.unit === 'degree') {\n              result[paramName] = paramValue * Math.PI / 180; // Convert to radians\n            } else {\n              result[paramName] = paramValue;\n            }\n          });\n        }\n        break;\n      case 'unit':\n        if (value.name) {\n          result.units = value.name.toLowerCase();\n          if (result.units === 'metre') {\n            result.units = 'meter';\n          }\n        }\n        if (value.conversion_factor) {\n          result.to_meter = value.conversion_factor;\n        }\n        break;\n      case 'base_crs':\n        transformPROJJSON(value, result); // Pass `result` directly\n        result.datumCode = value.id ? value.id.authority + '_' + value.id.code : value.name; // Set datumCode\n        break;\n      default:\n        // Ignore irrelevant or unneeded properties\n        break;\n    }\n  });\n\n  // Additional calculated properties\n  if (result.latitude_of_false_origin !== undefined) {\n    result.lat0 = result.latitude_of_false_origin; // Already in radians\n  }\n  if (result.longitude_of_false_origin !== undefined) {\n    result.long0 = result.longitude_of_false_origin;\n  }\n  if (result.latitude_of_standard_parallel !== undefined) {\n    result.lat0 = result.latitude_of_standard_parallel;\n    result.lat1 = result.latitude_of_standard_parallel;\n  }\n  if (result.latitude_of_1st_standard_parallel !== undefined) {\n    result.lat1 = result.latitude_of_1st_standard_parallel;\n  }\n  if (result.latitude_of_2nd_standard_parallel !== undefined) {\n    result.lat2 = result.latitude_of_2nd_standard_parallel;\n  }\n  if (result.latitude_of_projection_centre !== undefined) {\n    result.lat0 = result.latitude_of_projection_centre;\n  }\n  if (result.longitude_of_projection_centre !== undefined) {\n    result.longc = result.longitude_of_projection_centre;\n  }\n  if (result.easting_at_false_origin !== undefined) {\n    result.x0 = result.easting_at_false_origin;\n  }\n  if (result.northing_at_false_origin !== undefined) {\n    result.y0 = result.northing_at_false_origin;\n  }\n  if (result.latitude_of_natural_origin !== undefined) {\n    result.lat0 = result.latitude_of_natural_origin;\n  }\n  if (result.longitude_of_natural_origin !== undefined) {\n    result.long0 = result.longitude_of_natural_origin;\n  }\n  if (result.longitude_of_origin !== undefined) {\n    result.long0 = result.longitude_of_origin;\n  }\n  if (result.false_easting !== undefined) {\n    result.x0 = result.false_easting;\n  }\n  if (result.easting_at_projection_centre) {\n    result.x0 = result.easting_at_projection_centre;\n  }\n  if (result.false_northing !== undefined) {\n    result.y0 = result.false_northing;\n  }\n  if (result.northing_at_projection_centre) {\n    result.y0 = result.northing_at_projection_centre;\n  }\n  if (result.standard_parallel_1 !== undefined) {\n    result.lat1 = result.standard_parallel_1;\n  }\n  if (result.standard_parallel_2 !== undefined) {\n    result.lat2 = result.standard_parallel_2;\n  }\n  if (result.scale_factor_at_natural_origin !== undefined) {\n    result.k0 = result.scale_factor_at_natural_origin;\n  }\n  if (result.scale_factor_at_projection_centre !== undefined) {\n    result.k0 = result.scale_factor_at_projection_centre;\n  }\n  if (result.scale_factor_on_pseudo_standard_parallel !== undefined) {\n    result.k0 = result.scale_factor_on_pseudo_standard_parallel;\n  }\n  if (result.azimuth !== undefined) {\n    result.alpha = result.azimuth;\n  }\n  if (result.azimuth_at_projection_centre !== undefined) {\n    result.alpha = result.azimuth_at_projection_centre;\n  }\n  if (result.angle_from_rectified_to_skew_grid) {\n    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;\n  }\n\n  // Apply projection defaults\n  applyProjectionDefaults(result);\n  return result;\n}","map":{"version":3,"names":["applyProjectionDefaults","processUnit","unit","result","units","to_meter","undefined","toLowerCase","name","conversion_factor","toValue","valueOrObject","value","calculateEllipsoid","ellipsoid","radius","a","rf","semi_major_axis","inverse_flattening","semi_minor_axis","transformPROJJSON","projjson","type","source_crs","transformation","method","nadgrids","parameters","datum_params","map","param","Object","keys","forEach","key","srsCode","projName","conversion","ellps","prime_meridian","from_greenwich","longitude","Math","PI","long0","axis","direction","Error","join","authority","code","title","paramName","replace","paramValue","datumCode","id","latitude_of_false_origin","lat0","longitude_of_false_origin","latitude_of_standard_parallel","lat1","latitude_of_1st_standard_parallel","latitude_of_2nd_standard_parallel","lat2","latitude_of_projection_centre","longitude_of_projection_centre","longc","easting_at_false_origin","x0","northing_at_false_origin","y0","latitude_of_natural_origin","longitude_of_natural_origin","longitude_of_origin","false_easting","easting_at_projection_centre","false_northing","northing_at_projection_centre","standard_parallel_1","standard_parallel_2","scale_factor_at_natural_origin","k0","scale_factor_at_projection_centre","scale_factor_on_pseudo_standard_parallel","azimuth","alpha","azimuth_at_projection_centre","angle_from_rectified_to_skew_grid","rectified_grid_angle"],"sources":["D:/OneDrive/web/test/node_modules/wkt-parser/transformPROJJSON.js"],"sourcesContent":["import { applyProjectionDefaults } from './util.js';\n\n// Helper function to process units and to_meter\nfunction processUnit(unit) {\n  let result = { units: null, to_meter: undefined };\n\n  if (typeof unit === 'string') {\n    result.units = unit.toLowerCase();\n    if (result.units === 'metre') {\n      result.units = 'meter'; // Normalize 'metre' to 'meter'\n    }\n    if (result.units === 'meter') {\n      result.to_meter = 1; // Only set to_meter if units are 'meter'\n    }\n  } else if (unit && unit.name) {\n    result.units = unit.name.toLowerCase();\n    if (result.units === 'metre') {\n      result.units = 'meter'; // Normalize 'metre' to 'meter'\n    }\n    result.to_meter = unit.conversion_factor;\n  }\n\n  return result;\n}\n\nfunction toValue(valueOrObject) {\n  if (typeof valueOrObject === 'object') {\n    return valueOrObject.value * valueOrObject.unit.conversion_factor;\n  }\n  return valueOrObject;\n}\n\nfunction calculateEllipsoid(value, result) {\n  if (value.ellipsoid.radius) {\n    result.a = value.ellipsoid.radius;\n    result.rf = 0;\n  } else {\n    result.a = toValue(value.ellipsoid.semi_major_axis);\n    if (value.ellipsoid.inverse_flattening !== undefined) {\n      result.rf = value.ellipsoid.inverse_flattening;\n    } else if (value.ellipsoid.semi_major_axis !== undefined && value.ellipsoid.semi_minor_axis !== undefined) {\n      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));\n    }\n  }\n}\n\nexport function transformPROJJSON(projjson, result = {}) {\n  if (!projjson || typeof projjson !== 'object') {\n    return projjson; // Return primitive values as-is\n  }\n\n  if (projjson.type === 'BoundCRS') {\n    transformPROJJSON(projjson.source_crs, result);\n\n    if (projjson.transformation) {\n      if (projjson.transformation.method && projjson.transformation.method.name === 'NTv2') {\n        // Set nadgrids to the filename from the parameterfile\n        result.nadgrids = projjson.transformation.parameters[0].value;\n      } else {\n        // Populate datum_params if no parameterfile is found\n        result.datum_params = projjson.transformation.parameters.map((param) => param.value);\n      }\n    }\n    return result; // Return early for BoundCRS\n  }\n\n  // Handle specific keys in PROJJSON\n  Object.keys(projjson).forEach((key) => {\n    const value = projjson[key];\n    if (value === null) {\n      return;\n    }\n\n    switch (key) {\n      case 'name':\n        if (result.srsCode) {\n          break;\n        }\n        result.name = value;\n        result.srsCode = value; // Map `name` to `srsCode`\n        break;\n\n      case 'type':\n        if (value === 'GeographicCRS') {\n          result.projName = 'longlat';\n        } else if (value === 'ProjectedCRS' && projjson.conversion && projjson.conversion.method) {\n          result.projName = projjson.conversion.method.name; // Retain original capitalization\n        }\n        break;\n\n      case 'datum':\n      case 'datum_ensemble': // Handle both datum and ensemble\n        if (value.ellipsoid) {\n          // Extract ellipsoid properties\n          result.ellps = value.ellipsoid.name;\n          calculateEllipsoid(value, result);\n        }\n        if (value.prime_meridian) {\n          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180; // Convert to radians\n        }\n        break;\n\n      case 'ellipsoid':\n        result.ellps = value.name;\n        calculateEllipsoid(value, result);\n        break;\n\n      case 'prime_meridian':\n        result.long0 = (value.longitude || 0) * Math.PI / 180; // Convert to radians\n        break;\n\n      case 'coordinate_system':\n        if (value.axis) {\n          result.axis = value.axis\n            .map((axis) => {\n              const direction = axis.direction;\n              if (direction === 'east') return 'e';\n              if (direction === 'north') return 'n';\n              if (direction === 'west') return 'w';\n              if (direction === 'south') return 's';\n              throw new Error(`Unknown axis direction: ${direction}`);\n            })\n            .join('') + 'u'; // Combine into a single string (e.g., \"enu\")\n\n          if (value.unit) {\n            const { units, to_meter } = processUnit(value.unit);\n            result.units = units;\n            result.to_meter = to_meter;\n          } else if (value.axis[0] && value.axis[0].unit) {\n            const { units, to_meter } = processUnit(value.axis[0].unit);\n            result.units = units;\n            result.to_meter = to_meter;\n          }\n        }\n        break;\n        \n      case 'id':\n        if (value.authority && value.code) {\n          result.title = value.authority + ':' + value.code;\n        }\n        break;\n\n      case 'conversion':\n        if (value.method && value.method.name) {\n          result.projName = value.method.name; // Retain original capitalization\n        }\n        if (value.parameters) {\n          value.parameters.forEach((param) => {\n            const paramName = param.name.toLowerCase().replace(/\\s+/g, '_');\n            const paramValue = param.value;\n            if (param.unit && param.unit.conversion_factor) {\n              result[paramName] = paramValue * param.unit.conversion_factor; // Convert to radians or meters\n            } else if (param.unit === 'degree') {\n              result[paramName] = paramValue * Math.PI / 180; // Convert to radians\n            } else {\n              result[paramName] = paramValue;\n            }\n          });\n        }\n        break;\n\n      case 'unit':\n        if (value.name) {\n          result.units = value.name.toLowerCase();\n          if (result.units === 'metre') {\n            result.units = 'meter';\n          }\n        }\n        if (value.conversion_factor) {\n          result.to_meter = value.conversion_factor;\n        }\n        break;\n\n      case 'base_crs':\n        transformPROJJSON(value, result); // Pass `result` directly\n        result.datumCode = value.id ? value.id.authority + '_' + value.id.code : value.name; // Set datumCode\n        break;\n\n      default:\n        // Ignore irrelevant or unneeded properties\n        break;\n    }\n  });\n\n  // Additional calculated properties\n  if (result.latitude_of_false_origin !== undefined) {\n    result.lat0 = result.latitude_of_false_origin; // Already in radians\n  }\n  if (result.longitude_of_false_origin !== undefined) {\n    result.long0 = result.longitude_of_false_origin;\n  }\n  if (result.latitude_of_standard_parallel !== undefined) {\n    result.lat0 = result.latitude_of_standard_parallel;\n    result.lat1 = result.latitude_of_standard_parallel;\n  }\n  if (result.latitude_of_1st_standard_parallel !== undefined) {\n    result.lat1 = result.latitude_of_1st_standard_parallel;\n  }\n  if (result.latitude_of_2nd_standard_parallel !== undefined) {\n    result.lat2 = result.latitude_of_2nd_standard_parallel; \n  }\n  if (result.latitude_of_projection_centre !== undefined) {\n    result.lat0 = result.latitude_of_projection_centre;\n  }\n  if (result.longitude_of_projection_centre !== undefined) {\n    result.longc = result.longitude_of_projection_centre;\n  }\n  if (result.easting_at_false_origin !== undefined) {\n    result.x0 = result.easting_at_false_origin;\n  }\n  if (result.northing_at_false_origin !== undefined) {\n    result.y0 = result.northing_at_false_origin;\n  }\n  if (result.latitude_of_natural_origin !== undefined) {\n    result.lat0 = result.latitude_of_natural_origin;\n  }\n  if (result.longitude_of_natural_origin !== undefined) {\n    result.long0 = result.longitude_of_natural_origin;\n  }\n  if (result.longitude_of_origin !== undefined) {\n    result.long0 = result.longitude_of_origin;\n  }\n  if (result.false_easting !== undefined) {\n    result.x0 = result.false_easting;\n  }\n  if (result.easting_at_projection_centre) {\n    result.x0 = result.easting_at_projection_centre;\n  }\n  if (result.false_northing !== undefined) {\n    result.y0 = result.false_northing;\n  }\n  if (result.northing_at_projection_centre) {\n    result.y0 = result.northing_at_projection_centre;\n  }\n  if (result.standard_parallel_1 !== undefined) {\n    result.lat1 = result.standard_parallel_1;\n  }\n  if (result.standard_parallel_2 !== undefined) {\n    result.lat2 = result.standard_parallel_2;\n  }\n  if (result.scale_factor_at_natural_origin !== undefined) {\n    result.k0 = result.scale_factor_at_natural_origin;\n  }\n  if (result.scale_factor_at_projection_centre !== undefined) {\n    result.k0 = result.scale_factor_at_projection_centre;\n  }\n  if (result.scale_factor_on_pseudo_standard_parallel !== undefined) {  \n    result.k0 = result.scale_factor_on_pseudo_standard_parallel;\n  }\n  if (result.azimuth !== undefined) {\n    result.alpha = result.azimuth;\n  }\n  if (result.azimuth_at_projection_centre !== undefined) {\n    result.alpha = result.azimuth_at_projection_centre;\n  }\n  if (result.angle_from_rectified_to_skew_grid) {\n    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;\n  }\n\n  // Apply projection defaults\n  applyProjectionDefaults(result);\n\n  return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}