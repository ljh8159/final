{"ast":null,"code":"import { PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_NODATUM, R2D, SRS_WGS84_ESQUARED, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR } from './constants/values';\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from './common/adjust_lon';\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n  return point;\n}\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {\n    x: -point.x,\n    y: point.y\n  };\n  var output = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var attemptedGrids = [];\n  outer: for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log('Unable to find mandatory grid \\'' + grid.name + '\\'');\n        return -1;\n      }\n      continue;\n    }\n    var subgrids = grid.grid.subgrids;\n    for (var j = 0, jj = subgrids.length; j < jj; j++) {\n      var subgrid = subgrids[j];\n      // skip tables that don't match our point at all\n      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n      var minX = subgrid.ll[0] - epsilon;\n      var minY = subgrid.ll[1] - epsilon;\n      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n        continue;\n      }\n      output = applySubgridShift(input, inverse, subgrid);\n      if (!isNaN(output.x)) {\n        break outer;\n      }\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log('Failed to find a grid shift table for location \\'' + -input.x * R2D + ' ' + input.y * R2D + ' tried: \\'' + attemptedGrids + '\\'');\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  if (isNaN(pin.x)) {\n    return val;\n  }\n  var tb = {\n    x: pin.x,\n    y: pin.y\n  };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9,\n      tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log('Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.');\n        break;\n      }\n      dif = {\n        x: tb.x - (del.x + t.x),\n        y: tb.y - (del.y + t.y)\n      };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log('Inverse grid shift iterator failed to converge.');\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\nfunction nadInterpolate(pin, ct) {\n  var t = {\n    x: pin.x / ct.del[0],\n    y: pin.y / ct.del[1]\n  };\n  var indx = {\n    x: Math.floor(t.x),\n    y: Math.floor(t.y)\n  };\n  var frct = {\n    x: t.x - 1.0 * indx.x,\n    y: t.y - 1.0 * indx.y\n  };\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = indx.y * ct.lim[0] + indx.x;\n  var f00 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx++;\n  var f10 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx += ct.lim[0];\n  var f11 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx--;\n  var f01 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  var m11 = frct.x * frct.y,\n    m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y),\n    m01 = (1.0 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}","map":{"version":3,"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_NODATUM","R2D","SRS_WGS84_ESQUARED","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","geodeticToGeocentric","geocentricToGeodetic","geocentricToWgs84","geocentricFromWgs84","compareDatums","adjust_lon","checkParams","type","source","dest","point","datum_type","source_a","a","source_es","es","gridShiftCode","applyGridShift","undefined","dest_a","dest_b","b","dest_es","datum_params","destGridShiftResult","inverse","grids","length","console","log","input","x","y","output","Number","NaN","attemptedGrids","outer","i","grid","push","name","isNull","mandatory","subgrids","j","jj","subgrid","epsilon","Math","abs","del","minX","ll","minY","maxX","lim","maxY","applySubgridShift","isNaN","pin","ct","val","tb","PI","t","nadInterpolate","tol","dif","indx","floor","frct","inx","f00","cvs","f10","f11","f01","m11","m10","m00","m01"],"sources":["D:/OneDrive/web/test/node_modules/proj4/lib/datum_transform.js"],"sourcesContent":["import {\n  PJD_3PARAM,\n  PJD_7PARAM,\n  PJD_GRIDSHIFT,\n  PJD_NODATUM,\n  R2D,\n  SRS_WGS84_ESQUARED,\n  SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR\n} from './constants/values';\n\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from './common/adjust_lon';\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\n\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = { x: -point.x, y: point.y };\n  var output = { x: Number.NaN, y: Number.NaN };\n  var attemptedGrids = [];\n  outer:\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log('Unable to find mandatory grid \\'' + grid.name + '\\'');\n        return -1;\n      }\n      continue;\n    }\n    var subgrids = grid.grid.subgrids;\n    for (var j = 0, jj = subgrids.length; j < jj; j++) {\n      var subgrid = subgrids[j];\n      // skip tables that don't match our point at all\n      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n      var minX = subgrid.ll[0] - epsilon;\n      var minY = subgrid.ll[1] - epsilon;\n      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n        continue;\n      }\n      output = applySubgridShift(input, inverse, subgrid);\n      if (!isNaN(output.x)) {\n        break outer;\n      }\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log('Failed to find a grid shift table for location \\''\n      + -input.x * R2D + ' ' + input.y * R2D + ' tried: \\'' + attemptedGrids + '\\'');\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = { x: Number.NaN, y: Number.NaN };\n  if (isNaN(pin.x)) {\n    return val;\n  }\n  var tb = { x: pin.x, y: pin.y };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log('Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.');\n        break;\n      }\n      dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log('Inverse grid shift iterator failed to converge.');\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };\n  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };\n  var frct = { x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y };\n  var val = { x: Number.NaN, y: Number.NaN };\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };\n  inx++;\n  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };\n  inx += ct.lim[0];\n  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };\n  inx--;\n  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}