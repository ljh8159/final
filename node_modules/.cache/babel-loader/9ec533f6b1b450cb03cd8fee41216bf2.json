{"ast":null,"code":"class PROJJSONBuilderBase {\n  static getId(node) {\n    const idNode = node.find(child => Array.isArray(child) && child[0] === 'ID');\n    if (idNode && idNode.length >= 3) {\n      return {\n        authority: idNode[1],\n        code: parseInt(idNode[2], 10)\n      };\n    }\n    return null;\n  }\n  static convertUnit(node, type = 'unit') {\n    if (!node || node.length < 3) {\n      return {\n        type,\n        name: 'unknown',\n        conversion_factor: null\n      };\n    }\n    const name = node[1];\n    const conversionFactor = parseFloat(node[2]) || null;\n    const idNode = node.find(child => Array.isArray(child) && child[0] === 'ID');\n    const id = idNode ? {\n      authority: idNode[1],\n      code: parseInt(idNode[2], 10)\n    } : null;\n    return {\n      type,\n      name,\n      conversion_factor: conversionFactor,\n      id\n    };\n  }\n  static convertAxis(node) {\n    const name = node[1] || 'Unknown';\n\n    // Determine the direction\n    let direction;\n    const abbreviationMatch = name.match(/^\\((.)\\)$/); // Match abbreviations like \"(E)\" or \"(N)\"\n    if (abbreviationMatch) {\n      // Use the abbreviation to determine the direction\n      const abbreviation = abbreviationMatch[1].toUpperCase();\n      if (abbreviation === 'E') direction = 'east';else if (abbreviation === 'N') direction = 'north';else if (abbreviation === 'U') direction = 'up';else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);\n    } else {\n      // Use the explicit direction provided in the AXIS node\n      direction = node[2] ? node[2].toLowerCase() : 'unknown';\n    }\n    const orderNode = node.find(child => Array.isArray(child) && child[0] === 'ORDER');\n    const order = orderNode ? parseInt(orderNode[1], 10) : null;\n    const unitNode = node.find(child => Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT'));\n    const unit = this.convertUnit(unitNode);\n    return {\n      name,\n      direction,\n      // Use the valid PROJJSON direction value\n      unit,\n      order\n    };\n  }\n  static extractAxes(node) {\n    return node.filter(child => Array.isArray(child) && child[0] === 'AXIS').map(axis => this.convertAxis(axis)).sort((a, b) => (a.order || 0) - (b.order || 0)); // Sort by the \"order\" property\n  }\n  static convert(node, result = {}) {\n    switch (node[0]) {\n      case 'PROJCRS':\n        result.type = 'ProjectedCRS';\n        result.name = node[1];\n        result.base_crs = node.find(child => Array.isArray(child) && child[0] === 'BASEGEOGCRS') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'BASEGEOGCRS')) : null;\n        result.conversion = node.find(child => Array.isArray(child) && child[0] === 'CONVERSION') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'CONVERSION')) : null;\n        const csNode = node.find(child => Array.isArray(child) && child[0] === 'CS');\n        if (csNode) {\n          result.coordinate_system = {\n            type: csNode[1],\n            axis: this.extractAxes(node)\n          };\n        }\n        const lengthUnitNode = node.find(child => Array.isArray(child) && child[0] === 'LENGTHUNIT');\n        if (lengthUnitNode) {\n          const unit = this.convertUnit(lengthUnitNode);\n          result.coordinate_system.unit = unit; // Add unit to coordinate_system\n        }\n        result.id = this.getId(node);\n        break;\n      case 'BASEGEOGCRS':\n      case 'GEOGCRS':\n        result.type = 'GeographicCRS';\n        result.name = node[1];\n\n        // Handle DATUM or ENSEMBLE\n        const datumOrEnsembleNode = node.find(child => Array.isArray(child) && (child[0] === 'DATUM' || child[0] === 'ENSEMBLE'));\n        if (datumOrEnsembleNode) {\n          const datumOrEnsemble = this.convert(datumOrEnsembleNode);\n          if (datumOrEnsembleNode[0] === 'ENSEMBLE') {\n            result.datum_ensemble = datumOrEnsemble;\n          } else {\n            result.datum = datumOrEnsemble;\n          }\n          const primem = node.find(child => Array.isArray(child) && child[0] === 'PRIMEM');\n          if (primem && primem[1] !== 'Greenwich') {\n            datumOrEnsemble.prime_meridian = {\n              name: primem[1],\n              longitude: parseFloat(primem[2])\n            };\n          }\n        }\n        result.coordinate_system = {\n          type: 'ellipsoidal',\n          axis: this.extractAxes(node)\n        };\n        result.id = this.getId(node);\n        break;\n      case 'DATUM':\n        result.type = 'GeodeticReferenceFrame';\n        result.name = node[1];\n        result.ellipsoid = node.find(child => Array.isArray(child) && child[0] === 'ELLIPSOID') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'ELLIPSOID')) : null;\n        break;\n      case 'ENSEMBLE':\n        result.type = 'DatumEnsemble';\n        result.name = node[1];\n\n        // Extract ensemble members\n        result.members = node.filter(child => Array.isArray(child) && child[0] === 'MEMBER').map(member => ({\n          type: 'DatumEnsembleMember',\n          name: member[1],\n          id: this.getId(member) // Extract ID as { authority, code }\n        }));\n\n        // Extract accuracy\n        const accuracyNode = node.find(child => Array.isArray(child) && child[0] === 'ENSEMBLEACCURACY');\n        if (accuracyNode) {\n          result.accuracy = parseFloat(accuracyNode[1]);\n        }\n\n        // Extract ellipsoid\n        const ellipsoidNode = node.find(child => Array.isArray(child) && child[0] === 'ELLIPSOID');\n        if (ellipsoidNode) {\n          result.ellipsoid = this.convert(ellipsoidNode); // Convert the ellipsoid node\n        }\n\n        // Extract identifier for the ensemble\n        result.id = this.getId(node);\n        break;\n      case 'ELLIPSOID':\n        result.type = 'Ellipsoid';\n        result.name = node[1];\n        result.semi_major_axis = parseFloat(node[2]);\n        result.inverse_flattening = parseFloat(node[3]);\n        const units = node.find(child => Array.isArray(child) && child[0] === 'LENGTHUNIT') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'LENGTHUNIT'), result) : null;\n        break;\n      case 'CONVERSION':\n        result.type = 'Conversion';\n        result.name = node[1];\n        result.method = node.find(child => Array.isArray(child) && child[0] === 'METHOD') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'METHOD')) : null;\n        result.parameters = node.filter(child => Array.isArray(child) && child[0] === 'PARAMETER').map(param => this.convert(param));\n        break;\n      case 'METHOD':\n        result.type = 'Method';\n        result.name = node[1];\n        result.id = this.getId(node);\n        break;\n      case 'PARAMETER':\n        result.type = 'Parameter';\n        result.name = node[1];\n        result.value = parseFloat(node[2]);\n        result.unit = this.convertUnit(node.find(child => Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT')));\n        result.id = this.getId(node);\n        break;\n      case 'BOUNDCRS':\n        result.type = 'BoundCRS';\n\n        // Process SOURCECRS\n        const sourceCrsNode = node.find(child => Array.isArray(child) && child[0] === 'SOURCECRS');\n        if (sourceCrsNode) {\n          const sourceCrsContent = sourceCrsNode.find(child => Array.isArray(child));\n          result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;\n        }\n\n        // Process TARGETCRS\n        const targetCrsNode = node.find(child => Array.isArray(child) && child[0] === 'TARGETCRS');\n        if (targetCrsNode) {\n          const targetCrsContent = targetCrsNode.find(child => Array.isArray(child));\n          result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;\n        }\n\n        // Process ABRIDGEDTRANSFORMATION\n        const transformationNode = node.find(child => Array.isArray(child) && child[0] === 'ABRIDGEDTRANSFORMATION');\n        if (transformationNode) {\n          result.transformation = this.convert(transformationNode);\n        } else {\n          result.transformation = null;\n        }\n        break;\n      case 'ABRIDGEDTRANSFORMATION':\n        result.type = 'Transformation';\n        result.name = node[1];\n        result.method = node.find(child => Array.isArray(child) && child[0] === 'METHOD') ? this.convert(node.find(child => Array.isArray(child) && child[0] === 'METHOD')) : null;\n        result.parameters = node.filter(child => Array.isArray(child) && (child[0] === 'PARAMETER' || child[0] === 'PARAMETERFILE')).map(param => {\n          if (param[0] === 'PARAMETER') {\n            return this.convert(param);\n          } else if (param[0] === 'PARAMETERFILE') {\n            return {\n              name: param[1],\n              value: param[2],\n              id: {\n                'authority': 'EPSG',\n                'code': 8656\n              }\n            };\n          }\n        });\n\n        // Adjust the Scale difference parameter if present\n        if (result.parameters.length === 7) {\n          const scaleDifference = result.parameters[6];\n          if (scaleDifference.name === 'Scale difference') {\n            scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;\n          }\n        }\n        result.id = this.getId(node);\n        break;\n      case 'AXIS':\n        if (!result.coordinate_system) {\n          result.coordinate_system = {\n            type: 'unspecified',\n            axis: []\n          };\n        }\n        result.coordinate_system.axis.push(this.convertAxis(node));\n        break;\n      case 'LENGTHUNIT':\n        const unit = this.convertUnit(node, 'LinearUnit');\n        if (result.coordinate_system && result.coordinate_system.axis) {\n          result.coordinate_system.axis.forEach(axis => {\n            if (!axis.unit) {\n              axis.unit = unit;\n            }\n          });\n        }\n        if (unit.conversion_factor && unit.conversion_factor !== 1) {\n          if (result.semi_major_axis) {\n            result.semi_major_axis = {\n              value: result.semi_major_axis,\n              unit\n            };\n          }\n        }\n        break;\n      default:\n        result.keyword = node[0];\n        break;\n    }\n    return result;\n  }\n}\nexport default PROJJSONBuilderBase;","map":{"version":3,"names":["PROJJSONBuilderBase","getId","node","idNode","find","child","Array","isArray","length","authority","code","parseInt","convertUnit","type","name","conversion_factor","conversionFactor","parseFloat","id","convertAxis","direction","abbreviationMatch","match","abbreviation","toUpperCase","Error","toLowerCase","orderNode","order","unitNode","unit","extractAxes","filter","map","axis","sort","a","b","convert","result","base_crs","conversion","csNode","coordinate_system","lengthUnitNode","datumOrEnsembleNode","datumOrEnsemble","datum_ensemble","datum","primem","prime_meridian","longitude","ellipsoid","members","member","accuracyNode","accuracy","ellipsoidNode","semi_major_axis","inverse_flattening","units","method","parameters","param","value","sourceCrsNode","sourceCrsContent","source_crs","targetCrsNode","targetCrsContent","target_crs","transformationNode","transformation","scaleDifference","Math","round","push","forEach","keyword"],"sources":["D:/OneDrive/web/test/node_modules/wkt-parser/PROJJSONBuilderBase.js"],"sourcesContent":["class PROJJSONBuilderBase {\n  static getId(node) {\n    const idNode = node.find((child) => Array.isArray(child) && child[0] === 'ID');\n    if (idNode && idNode.length >= 3) {\n      return {\n        authority: idNode[1],\n        code: parseInt(idNode[2], 10),\n      };\n    }\n    return null;\n  }\n\n  static convertUnit(node, type = 'unit') {\n    if (!node || node.length < 3) {\n      return { type, name: 'unknown', conversion_factor: null };\n    }\n\n    const name = node[1];\n    const conversionFactor = parseFloat(node[2]) || null;\n\n    const idNode = node.find((child) => Array.isArray(child) && child[0] === 'ID');\n    const id = idNode\n      ? {\n        authority: idNode[1],\n        code: parseInt(idNode[2], 10),\n      }\n      : null;\n\n    return {\n      type,\n      name,\n      conversion_factor: conversionFactor,\n      id,\n    };\n  }\n\n  static convertAxis(node) {\n    const name = node[1] || 'Unknown';\n\n    // Determine the direction\n    let direction;\n    const abbreviationMatch = name.match(/^\\((.)\\)$/); // Match abbreviations like \"(E)\" or \"(N)\"\n    if (abbreviationMatch) {\n      // Use the abbreviation to determine the direction\n      const abbreviation = abbreviationMatch[1].toUpperCase();\n      if (abbreviation === 'E') direction = 'east';\n      else if (abbreviation === 'N') direction = 'north';\n      else if (abbreviation === 'U') direction = 'up';\n      else throw new Error(`Unknown axis abbreviation: ${abbreviation}`);\n    } else {\n      // Use the explicit direction provided in the AXIS node\n      direction = node[2] ? node[2].toLowerCase() : 'unknown';\n    }\n\n    const orderNode = node.find((child) => Array.isArray(child) && child[0] === 'ORDER');\n    const order = orderNode ? parseInt(orderNode[1], 10) : null;\n\n    const unitNode = node.find(\n      (child) =>\n        Array.isArray(child) &&\n        (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT')\n    );\n    const unit = this.convertUnit(unitNode);\n\n    return {\n      name,\n      direction, // Use the valid PROJJSON direction value\n      unit,\n      order,\n    };\n  }\n\n  static extractAxes(node) {\n    return node\n      .filter((child) => Array.isArray(child) && child[0] === 'AXIS')\n      .map((axis) => this.convertAxis(axis))\n      .sort((a, b) => (a.order || 0) - (b.order || 0)); // Sort by the \"order\" property\n  }\n\n  static convert(node, result = {}) {\n\n    switch (node[0]) {\n      case 'PROJCRS':\n        result.type = 'ProjectedCRS';\n        result.name = node[1];\n        result.base_crs = node.find((child) => Array.isArray(child) && child[0] === 'BASEGEOGCRS')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'BASEGEOGCRS'))\n          : null;\n        result.conversion = node.find((child) => Array.isArray(child) && child[0] === 'CONVERSION')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'CONVERSION'))\n          : null;\n\n        const csNode = node.find((child) => Array.isArray(child) && child[0] === 'CS');\n        if (csNode) {\n          result.coordinate_system = {\n            type: csNode[1],\n            axis: this.extractAxes(node),\n          };\n        }\n\n        const lengthUnitNode = node.find((child) => Array.isArray(child) && child[0] === 'LENGTHUNIT');\n        if (lengthUnitNode) {\n          const unit = this.convertUnit(lengthUnitNode);\n          result.coordinate_system.unit = unit; // Add unit to coordinate_system\n        }\n\n        result.id = this.getId(node);\n        break;\n\n      case 'BASEGEOGCRS':\n      case 'GEOGCRS':\n        result.type = 'GeographicCRS';\n        result.name = node[1];\n      \n        // Handle DATUM or ENSEMBLE\n        const datumOrEnsembleNode = node.find(\n          (child) => Array.isArray(child) && (child[0] === 'DATUM' || child[0] === 'ENSEMBLE')\n        );\n        if (datumOrEnsembleNode) {\n          const datumOrEnsemble = this.convert(datumOrEnsembleNode);\n          if (datumOrEnsembleNode[0] === 'ENSEMBLE') {\n            result.datum_ensemble = datumOrEnsemble;\n          } else {\n            result.datum = datumOrEnsemble;\n          }\n          const primem = node.find((child) => Array.isArray(child) && child[0] === 'PRIMEM');\n          if (primem && primem[1] !== 'Greenwich') {\n            datumOrEnsemble.prime_meridian = {\n              name: primem[1],\n              longitude: parseFloat(primem[2]),\n            }\n          }\n        }\n      \n        result.coordinate_system = {\n          type: 'ellipsoidal',\n          axis: this.extractAxes(node),\n        };\n      \n        result.id = this.getId(node);\n        break;\n\n      case 'DATUM':\n        result.type = 'GeodeticReferenceFrame';\n        result.name = node[1];\n        result.ellipsoid = node.find((child) => Array.isArray(child) && child[0] === 'ELLIPSOID')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'ELLIPSOID'))\n          : null;\n        break;\n      \n      case 'ENSEMBLE':\n        result.type = 'DatumEnsemble';\n        result.name = node[1];\n      \n        // Extract ensemble members\n        result.members = node\n          .filter((child) => Array.isArray(child) && child[0] === 'MEMBER')\n          .map((member) => ({\n            type: 'DatumEnsembleMember',\n            name: member[1],\n            id: this.getId(member), // Extract ID as { authority, code }\n          }));\n      \n        // Extract accuracy\n        const accuracyNode = node.find((child) => Array.isArray(child) && child[0] === 'ENSEMBLEACCURACY');\n        if (accuracyNode) {\n          result.accuracy = parseFloat(accuracyNode[1]);\n        }\n      \n        // Extract ellipsoid\n        const ellipsoidNode = node.find((child) => Array.isArray(child) && child[0] === 'ELLIPSOID');\n        if (ellipsoidNode) {\n          result.ellipsoid = this.convert(ellipsoidNode); // Convert the ellipsoid node\n        }\n      \n        // Extract identifier for the ensemble\n        result.id = this.getId(node);\n        break;\n\n      case 'ELLIPSOID':\n        result.type = 'Ellipsoid';\n        result.name = node[1];\n        result.semi_major_axis = parseFloat(node[2]);\n        result.inverse_flattening = parseFloat(node[3]);\n        const units = node.find((child) => Array.isArray(child) && child[0] === 'LENGTHUNIT')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'LENGTHUNIT'), result)\n          : null;\n        break;\n\n      case 'CONVERSION':\n        result.type = 'Conversion';\n        result.name = node[1];\n        result.method = node.find((child) => Array.isArray(child) && child[0] === 'METHOD')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'METHOD'))\n          : null;\n        result.parameters = node\n          .filter((child) => Array.isArray(child) && child[0] === 'PARAMETER')\n          .map((param) => this.convert(param));\n        break;\n\n      case 'METHOD':\n        result.type = 'Method';\n        result.name = node[1];\n        result.id = this.getId(node);\n        break;\n\n      case 'PARAMETER':\n        result.type = 'Parameter';\n        result.name = node[1];\n        result.value = parseFloat(node[2]);\n        result.unit = this.convertUnit(\n          node.find(\n            (child) =>\n              Array.isArray(child) &&\n              (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT')\n          )\n        );\n        result.id = this.getId(node);\n        break;\n\n      case 'BOUNDCRS':\n        result.type = 'BoundCRS';\n\n        // Process SOURCECRS\n        const sourceCrsNode = node.find((child) => Array.isArray(child) && child[0] === 'SOURCECRS');\n        if (sourceCrsNode) {\n          const sourceCrsContent = sourceCrsNode.find((child) => Array.isArray(child));\n          result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;\n        }\n\n        // Process TARGETCRS\n        const targetCrsNode = node.find((child) => Array.isArray(child) && child[0] === 'TARGETCRS');\n        if (targetCrsNode) {\n          const targetCrsContent = targetCrsNode.find((child) => Array.isArray(child));\n          result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;\n        }\n\n        // Process ABRIDGEDTRANSFORMATION\n        const transformationNode = node.find((child) => Array.isArray(child) && child[0] === 'ABRIDGEDTRANSFORMATION');\n        if (transformationNode) {\n          result.transformation = this.convert(transformationNode);\n        } else {\n          result.transformation = null;\n        }\n        break;\n\n      case 'ABRIDGEDTRANSFORMATION':\n        result.type = 'Transformation';\n        result.name = node[1];\n        result.method = node.find((child) => Array.isArray(child) && child[0] === 'METHOD')\n          ? this.convert(node.find((child) => Array.isArray(child) && child[0] === 'METHOD'))\n          : null;\n\n        result.parameters = node\n          .filter((child) => Array.isArray(child) && (child[0] === 'PARAMETER' || child[0] === 'PARAMETERFILE'))\n          .map((param) => {\n            if (param[0] === 'PARAMETER') {\n              return this.convert(param);\n            } else if (param[0] === 'PARAMETERFILE') {\n              return {\n                name: param[1],\n                value: param[2],\n                id: {\n                  'authority': 'EPSG',\n                  'code': 8656\n                }\n              };\n            }\n          });\n\n        // Adjust the Scale difference parameter if present\n        if (result.parameters.length === 7) {\n          const scaleDifference = result.parameters[6];\n          if (scaleDifference.name === 'Scale difference') {\n            scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;\n          }\n        }\n\n        result.id = this.getId(node);\n        break;\n      \n      case 'AXIS':\n        if (!result.coordinate_system) {\n          result.coordinate_system = { type: 'unspecified', axis: [] };\n        }\n        result.coordinate_system.axis.push(this.convertAxis(node));\n        break;\n      \n      case 'LENGTHUNIT':\n        const unit = this.convertUnit(node, 'LinearUnit');\n        if (result.coordinate_system && result.coordinate_system.axis) {\n          result.coordinate_system.axis.forEach((axis) => {\n            if (!axis.unit) {\n              axis.unit = unit;\n            }\n          });\n        }\n        if (unit.conversion_factor && unit.conversion_factor !== 1) {\n          if (result.semi_major_axis) {\n            result.semi_major_axis = {\n              value: result.semi_major_axis,\n              unit,\n            }\n          }\n        }\n        break;\n\n      default:\n        result.keyword = node[0];\n        break;\n    }\n\n    return result;\n  }\n}\n\nexport default PROJJSONBuilderBase;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}